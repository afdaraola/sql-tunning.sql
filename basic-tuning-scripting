explain plan for select * from championship;

select * from table(dbms_xplan.display);

explain plan
    set statement_id = 'x1'
    into plan_table
    for select * from championship;

select * from plan_table;

SELECT * FROM TABLE(dbms_xplan.display(statement_id=>'x1'));

SELECT *
FROM TABLE(DBMS_XPLAN.DISPLAY (FORMAT=>'ALL +OUTLINE'));
/*
 What to look for ?
-Look for TABLE ACCESS… (FULL) …
-Costly if the table is big
-Costly if performed many times
-Look for INDEX… (RANGE SCAN)…
-Expected for non-unique indexes
-Suspicious for unique indexes
 */

 --how to get execution plan in oracle using sql_id in Cursor
select * from table(dbms_xplan.display_cursor('&1', NULL, 'ALL'));

select * from table( DBMS_XPLAN.display_cursor('&1', NULL,'ADVANCED ROWS ALLSTATS'));

--how to get execution plan in oracle using sql_id in AWR/how to get old execution plan in oracle
select * from table( DBMS_XPLAN.DISPLAY_AWR('&1', NULL,NULL,'ADVANCED ROWS ALLSTATS'));

--How to find the change in explain plan in oracle for a sql id

set lines 155
    col execs for 999,999,999
    col avg_etime for 999,999.999
    col avg_lio for 999,999,999.9
    col begin_interval_time for a30
    col node for 99999
    break on plan_hash_value on startup_time skip 1
SELECT ss.snap_id,
       ss.instance_number node,
       begin_interval_time,
       sql_id,
       plan_hash_value,
       NVL(executions_delta,0) execs,
       (elapsed_time_delta/DECODE(NVL(executions_delta,0),0,1,executions_delta))/1000000
           avg_etime,
       (buffer_gets_delta /DECODE(NVL(buffer_gets_delta,0),0,1,executions_delta))
           avg_lio
FROM DBA_HIST_SQLSTAT S,
     DBA_HIST_SNAPSHOT SS
WHERE sql_id = NVL('&sql_id','fhf133jjk234')
  AND ss.snap_id = S.snap_id
  AND ss.instance_number = S.instance_number
  AND executions_delta > 0
ORDER BY 1,2,3;
/

/*
 Autotrace Utility installation
cd [ORACLE_HOME]/rdbms/admin
log into SQL*Plus as SYSTEM
Run @utlxplan
Run CREATE PUBLIC SYNONYM PLAN_TABLE FOR PLAN_TABLE;
Run GRANT ALL ON PLAN_TABLE TO PUBLIC;
Log in to SQL*Plus as SYS or as SYSDBA
Run @plustrce
Run GRANT PLUSTRACE TO PUBLIC;

 Understanding Autotrace Output
Autotrace shows two things
(a) Explain plan: Explain plan shows the plan for query and it shows exactly how the query will be executed in Database.It will shows the cost ,cardinality and bytes for the each step in the explain plan.Execution Plan produced by Autotrace contains the following:
Line number of each execution step
The relationship number between each step and its parent
Each step of the plan
shows any database links or parallel servers used
(b) Statistics: Lots of statistics will be shown.Some of the statistics are
(i) Recursive calls: Number of sql statement executed in order to execute the statement
(ii) DB block gets: The no of blocks read from buffer cache in current mode
(iii) Consistent gets: The no of blocks read from buffer cache in consistent reads
(iv)redo size: redo generated by sql
(v) physical reads: No of disks reads

 Syntax
set autotrace { off | on | traceonly } [explain] [statistics]
 */

set autotrace traceonly

/*
 Statistics
0 recursive calls
0 db block gets
15 consistent gets
3 physical reads
0 redo size
408 bytes sent via SQL*Net to client
355 bytes received via SQL*Net from client
2 SQL*Net roundtrips to/from client
0 sorts (memory)
0 sorts (disk)
1 rows processed

 How to Read the statistics

Logical Reads = Consistent Gets + DB Block Gets
Logical Reads = 15 + 0
Logical Reads = 15
Rows Processed = 1

That means we had to read 15 blocks to find 1 rows


 */

--Normal trace

alter session set sql_trace = true;  -- To put trace on

alter session set sql_trace = false;  -- To put trace off

--Full level with wait event And bind trace

alter session set events = '10046 trace name context forever, level 12';

--To put tracing off

alter session set events = '10046 trace name context off';

--Same as Normal trace

exec DBMS_SESSION.set_sql_trace(sql_trace => TRUE);

exec DBMS_SESSION.set_sql_trace(sql_trace => FALSE);
/*
Home » Oracle » Oracle Database » SQL trace, 10046 event in Oracle : trcsess, tkprof utility
SQL trace, 10046 event in Oracle : trcsess, tkprof utility
July 5, 2019 by techgoeasy 1 Comment

Tracing is a important part for Oracle database tuning. This will help capture all the problem statement , wait event which are responsible for slow running of the session.
Oracle database has provided has many quickest ways to trace the local session, other user session   and format the trace to make readable
SQL trace, 10046 event

Let us take some look at how to turn on SQL trace, 10046 event in  Oracle database and trcsess, tkprof utility
*/
Table of Contents
SQL Trace ,100046 event
How to identify the Trace files
how to check if trace is enabled in oracle
Oracle tkprof utility
Oracle trcsess utility
SQL Trace ,100046 event
If you want to trace in local session,here are the steps to turn on SQL trace

--Normal trace

alter session set sql_trace = true;  -- To put trace on

alter session set sql_trace = false;  -- To put trace off

--Full level with wait event And bind trace

alter session set events = '10046 trace name context forever, level 12';

--To put tracing off

alter session set events = '10046 trace name context off';

--Same as Normal trace

exec DBMS_SESSION.set_sql_trace(sql_trace => TRUE);

exec DBMS_SESSION.set_sql_trace(sql_trace => FALSE);

--If you want to trace in other running session,here are the steps

--Normal trace

execute dbms_system.set_sql_trace_in_session ('sid','serial',true);  -- To put tracing on

execute dbms_system.set_sql_trace_in_session ('sid','serial',true);   -- To put tracing off

--Full level with wait event And bind trace

execute dbms_system.set_ev('sid','serial',10046,12,'');

--To put trace off

execute dbms_system.set_ev('sid','serial',10046,12,'');

--How to identify the Trace files

--Below query can be used to find the local session trace file

select c.value || '/' || d.instance_name ||'_ora_' || a.spid || '.trc' trace
from v$process a, v$session b, v$parameter c, v$instance d
where a.addr = b.paddr
  and b.audsid = userenv('sessionid')
  and c.name = 'user_dump_dest';


select username,module,sid,sql_trace,sql_trace_waits,sql_trace_binds
from v$session where sql_trace='ENABLED';

--aSh

--(2) Most active session in last one hour can be found using active session history

SELECT sql_id,COUNT(*),ROUND(COUNT(*)/SUM(COUNT(*)) OVER(), 2) PCTLOAD
FROM gv$active_session_history
WHERE sample_time > SYSDATE - 1/24
  AND session_type = 'BACKGROUND'
GROUP BY sql_id
ORDER BY COUNT(*) DESC;
SELECT sql_id,COUNT(*),ROUND(COUNT(*)/SUM(COUNT(*)) OVER(), 2) PCTLOAD
FROM gv$active_session_history
WHERE sample_time > SYSDATE - 1/24
  AND session_type = 'FOREGROUND'
GROUP BY sql_id
ORDER BY COUNT(*) DESC;

--3) To find out the oracle wait events for which this session

SELECT sample_time, event, wait_time
FROM gv$active_session_history
WHERE session_id = &1
  AND session_serial# = &2

--(7) top sqls spent more on cpu/wait/io

select
    ash.SQL_ID ,
    sum(decode(a.session_state,'ON CPU',1,0)) "CPU",
    sum(decode(a.session_state,'WAITING',1,0))
                                              sum(decode(a.session_state,'WAITING', decode(en.wait_class, 'User I/O',1,0),0)) "WAIT" ,
        sum(decode(a.session_state,'WAITING', decode(en.wait_class, 'User I/O',1,0),0)) "IO" ,
    sum(decode(a.session_state,'ON CPU',1,1)) "TOTAL"
from v$active_session_history a,v$event_name en
where SQL_ID is not NULL and en.event#=a.event#


--Wait events
--You can find which event session is waiting for it by following query

select event from V$session_wait where sid=&1

--query to find full table scans in oracle
col event format a25
col module format a50
col File format 9999
col Block format 9999999
set lines 130
set trimspool on
select sessw.SID, sessw.EVENT, sessw.p1 "File",sessw.p2 "Block", sess.MODULE
from v$session_wait sessw, v$session sess
where sessw.sid = sess.sid
  and sessw.event like '%scattered%'
order by 1
/

--You can get the full text from sql_id using the below query
SELECT sql_text, parsing_schema_name, module
FROM v$sql
WHERE sql_id = '&1'

/*

 How to Avoid Full table scan in Oracle
Full table scan is not necessary evil. Oracle optimizer chooses the plan based on data point.
 If it has chosen full data scan, then it has certainly find it good. Also Quite often
 index scan might not be good for the query and it is most costly then full table scan.
 So we need analyze thoroughly before taking any decision on Full table scan

 Following are some of the things to check
(a) Stale Optimizer statistics: Please check if the optimizer stats available on the tables are current and does not differ much from actual data
(b) Check indexes and index clustering factor : You might be missing the right indexes
(c) The query might be using parallel clause and so choosing Full table scan as optimal plan
(d) Incorrect parameter settings for Optimizer_mode,optimizer_index_cost_adj, optimizer_index_caching


 */
